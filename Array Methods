//bubble sort
Array.prototype.bubblesort = function (callback = (a, b) => a > b) {
	array_error(this);
	for (let i = 0; i < this.length - 1; i++) {
		for (let j = 0; j < this.length - i - 1; j++) {
			if (callback(this[j], this[j + 1])) {
				let temp = this[j];
				this[j] = this[j + 1];
				this[j + 1] = temp;
			}
		}
	}
	return this;
};

//indexOf
function indexOf(arr, value) {
	array_error(_arr);
	for (let i = 0; i < arr.length; i++) {
		if (arr[i] === value) {
			return i;
		}
	}
}

//lastIndexOf
function lastIndexOf(arr, value) {
	array_error(arr);
	for (let i = arr.length - 1; i >= 0; i--) {
		if (arr[i] === value) {
			return i;
		}
	}
}

//max
Array.prototype.max = function () {
	let accumulator = this[0];
	array_error(this);
	for (let i = 0; i < this.length; i++) {
		if (this[i] > accumulator) {
			accumulator = this[i];
		}
	}
	return accumulator;
};

//min
Array.prototype.min = function () {
	let accumulator = this[0];
	array_error(this);
	for (let i = 0; i < this.length; i++) {
		if (this[i] < accumulator) {
			accumulator = this[i];
		}
	}
	return accumulator;
};

//avj
Array.prototype.avj = function (callback = (x) => x) {
	array_error(this);
	let sum = 0;
	for (let i = 0; i < this.length; i++) {
		sum += this[i];
	}
	return callback(sum / this.length);
};

//sum
Array.prototype.sum = function (callback = (x) => x) {
	array_error(this);
	let sum = 0;
	for (let i = 0; i < this.length; i++) {
		sum += this[i];
	}
	return callback(sum);
};

//shift
function shift(arr) {
	array_error(arr);
	for (let i = 0; i < arr.length; i++) {
		arr[i] = arr[i + 1];
	}
	arr.length = arr.length - 1;
	return arr[0];
}

//unshift
function unshift(arr, value) {
	array_error(arr);

	for (let i = arr.length; i >= 0; i--) {
		arr[i + 1] = arr[i];
	}
	arr.length = arr.length - 1;
	arr[0] = value;
	return arr.length;
}

//flatten
function flatten(arr) {
	array_error(arr);
	let flat = [];
	for (let i = 0; i < arr.length; i++) {
		if (Array.isArray(arr[i])) {
			flat = flat.concat(flatten(arr[i]));
		} else {
			flat.push(arr[i]);
		}
	}
	return flat;
}

//splice
function splice(arr, start, deleteCount, ...items) {
	array_error(_arr);
	return concat(slice(arr, start + deleteCount), concat(slice(arr, 0, start), items));
}

//slice
function slice(_arr, start, end) {
	array_error(_arr);
	let temparr = [];
	for (let i = 0; i < _arr.length; i++) {
		if (i >= start && i < end) {
			push(temparr, _arr[i]);
		}
	}

	return temparr;
}

//push
function push(arr, value) {
	array_error(arr);
	arr[arr.length] = value;
	return arr;
}

//concat
function concat(arr1, arr2) {
	array_error(arr1);
	array_error(arr2);
	let temparr = [];
	for (let i = 0; i < arr1.length; i++) {
		push(temparr, arr1[i]);
	}
	for (let i = 0; i < arr2.length; i++) {
		push(temparr, arr2[i]);
	}
	return temparr;
}

//includes
function includes(arr, value) {
	array_error(arr);
	for (let i = 0; i < arr.length; i++) {
		if (arr[i] === value) {
			return true;
		}
	}
	return false;
}

//pop
function pop(arr) {
	array_error(arr);
	let lastindex = arr[arr.length - 1];
	arr.length = arr.length - 1;
	return lastindex;
}

//fill
function fill(arr, value, fstIndex = 0, lstIndex) {
	array_error(arr);
	lstIndex ?? arr.length;
	for (let i = fstIndex; i < lstIndex; i++) {
		arr[i] = value;
	}
	return arr;
}

//filter
export function filter(arr, callback) {
	array_error(arr);
	let temparr = [];
	for (let i = 0; i < arr.length; i++) {
		if (callback(arr[i], i, arr)) {
			temparr[temparr.length] = arr[i];
		}
	}
	return temparr;
}

//find
function find(arr, callback) {
	array_error(arr);
	for (let i = 0; i < arr.length; i++) {
		if (callback(arr[i])) {
			return arr[i];
		}
	}
}

//findIndex
function findIndex(arr, callback) {
	array_error(arr);
	for (let i = 0; i < arr.length; i++) {
		if (callback(arr[i])) {
			return i;
		}
	}
	return -1;
}

//map
export function map(arr, callback) {
	array_error(arr);
	let temparr = [];
	for (let i = 0; i < arr.length; i++) {
		temparr[i] = callback(arr[i], i, arr);
	}
	return temparr;
}

//reduce
export function reduce(arr, callback, accumulator) {
	array_error(arr);
	accumulator ??= arr[0];
	for (let i = 0; i < arr.length; i++) {
		accumulator = callback(accumulator, arr[i], i, arr);
	}
	return accumulator;
}

//some
function some(arr, callback) {
	array_error(arr);
	for (let i = 0; i < arr.length; i++) {
		if (callback(arr[i])) {
			return true;
		}
	}
	return false;
}
//every
function every(arr, callback) {
	array_error(arr);
	for (let i = 0; i < arr.length; i++) {
		if (!callback(arr[i])) {
			return false;
		}
	}
	return true;
}

//equal
Array.prototype.equal = function (arr) {
	array_error(this);
	array_error(arr);
	for (let i = 0; i < arr.length; i++) {
		if (this[i] !== arr[i]) {
			return false;
		}
	}
	return true;
};

//intersection
Array.prototype.intersection = function (arr) {
	let temparr = [];
	array_error(this);
	array_error(arr);
	for (let i = 0; i < this.length; i++) {
		for (let j = 0; j < arr.length; j++) {
			if (this[i] === arr[j] && !includes(temparr, this[i])) {
				temparr[temparr.length] = this[i];
			}
		}
	}
	return temparr;
};

Array.prototype.union = function (arr) {
	let temparr = [];
	array_error(this);
	array_error(arr);
	for (let i = 0; i < this.length; i++) {
		temparr[temparr.length] = this[i];
	}
	for (let i = 0; i < arr.length; i++) {
		if (!includes(temparr, arr[i])) {
			temparr[temparr.length] = arr[i];
		}
	}
	return temparr;
};

//exclusive
Array.prototype.exclusive = function (arr) {
	array_error(this);
	array_error(arr);
	for (let i = 0; i < this.length; i++) {
		for (let j = 0; j < arr.length; j++) {
			if (includes(this, arr[i])) {
				return false;
			}
		}
	}
	return true;
};

//in between
Array.prototype.inbetween = function (start, end) {
	let temparr = [];
	array_error(this);
	end ??= this.max();
	if (start >= end) {
		return temparr;
	}
	for (let i = 0; i < this.length; i++) {
		if (this[i] > start && this[i] <= end) {
			temparr[temparr.length] = this[i];
		}
	}

	return temparr;
};

//group by
Array.prototype.groupby = function (callback) {
	let tempobj = {};
	array_error(this);
	for (let i = 0; i < this.length; i++) {
		let k = callback(this[i]);
		if (!tempobj[k]) {
			tempobj[k] = [];
		}
		tempobj[k][tempobj[k].length] = this[i];
	}
	return tempobj;
};

//unique
Array.prototype.unique = function () {
	let temparr = [];
	array_error(this);
	for (let i = 0; i < this.length; i++) {
		let active = true;
		for (let j = 0; j < temparr.length; j++) {
			if (i !== j && this[i] === this[j]) {
				active = false;
				break;
			}
		}

		if (active) {
			temparr[temparr.length] = this[i];
		}
	}
	return temparr;
};

//chunk
Array.prototype.chunk = function (size) {
	array_error(this);
	size ??= this.length;
	let temparr = [];
	for (let i = size - 1; i <= this.length; i += size) {
		let startpoint = size - 1 - i;
		let compose = [];
		for (let j = startpoint < 0 ? -startpoint : startpoint; j <= i; j++) {
			if (this[j]) {
				compose[compose.length] = this[j];
			}
		}
		temparr[temparr.length] = compose;
	}
	return temparr;
};

//compact
Array.prototype.compact = function () {
	array_error(this);
	let temparr = [];
	for (let i = 0; i < this.length; i++) {
		if (this[i]) {
			temparr[temparr.length] = this[i];
		}
	}
	return temparr;
};

//frompair
// Array.prototype.fromPair = function () {
// 	array_error(this);
// 	let tempobj = {};
// 	for (let i = 0; i < this.length; i++) {
// 		tempobj[i] = this[i];
// 	}
// 	return tempobj;
// };

//zip
Array.prototype.zip = function (...arr) {
	array_error(this);
	array_error(arr);
	console.log(arr);
	let temparr = [];
	let length = this.length >= arr.length ? this.length : arr.length;
	for (let i = 0; i < length; i++) {
		temparr[temparr.length] = [this[i], arr[i]];
	}
	return temparr;
};

function array_error(arr) {
	if (Object.prototype.toString.call(arr) !== "[object Array]") {
		throw new Error("Value must be an array");
	}
}

// module.exports = {
//   sort: sort,
//   indexOf: indexOf,
//   lastIndexOf: lastIndexOf,
//   includes: includes,
//   shift: shift,
//   unshift: unshift,
//   splice: splice,
//   slice: slice,
//   push: push,
//   fill: fill,
//   map: map,
//   filter: filter,
//   find: find,
//   findIndex: findIndex,
//   pop: pop,
//   concat: concat,
//   reduce: reduce,
//   some: some,
//   every: every,
//   max: max,
//   min: min,
//   avj: avj,
//   flatten: flatten,
//   equal: equal,
//   intersection: intersection,
//   union: union,
//   exclusive: exclusive,
// };
